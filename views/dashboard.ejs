<%- include('partials/header', { title: title, page: page }) %>

<div class="flex-wrapper">
  <div class="container content">
    <!-- Sentiment Cards Row -->
    <div class="row justify-content-center mt-4">
      <!-- Total Data Card -->
      <div class="col-xl-2 col-lg-2 col-md-4 col-sm-6 col-12 mb-4">
        <div class="card h-100">
          <div class="card-body text-center">
            <h6 class="card-subtitle mb-2 text-muted">Total Reviews</h6>
            <h3 class="card-title" id="totalReviews">0</h3>
            <div class="progress mt-2" style="height: 4px;">
              <div class="progress-bar bg-secondary" style="width: 100%"></div>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Sentiment Cards -->
      <% const sentimentCards = ['positif', 'negatif', 'netral', 'puas', 'kecewa']; %>
      <% sentimentCards.forEach(sentiment => { %>
        <div class="col-xl-2 col-lg-2 col-md-4 col-sm-6 col-12 mb-4">
          <div class="card h-100">
            <div class="card-body text-center">
              <h6 class="card-subtitle mb-2 text-muted"><%= sentiment.charAt(0).toUpperCase() + sentiment.slice(1) %></h6>
              <h3 class="card-title" id="<%= sentiment %>Count">0</h3>
              <div class="progress mt-2" style="height: 4px;">
                <div class="progress-bar" id="<%= sentiment %>Progress" style="width: 0%"></div>
              </div>
            </div>
          </div>
        </div>
      <% }); %>
    </div>
    
    <!-- Chart Row -->
    <div class="row w-100 justify-content-center">
      <div class="col-md-12 mb-4">
        <div class="card">
          <div class="card-header">
            <h5 class="card-title mb-0">Sentiment Distribution</h5>
          </div>
          <div class="card-body text-center">
            <div class="chart-container" style="position: relative; width: 100%; height: 300px;">
              <canvas id="sentimentChart"></canvas>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Sentiment by Time Chart -->
    <div class="row w-100 mb-4">
      <div class="col-md-12">
        <div class="card">
          <div class="card-header d-flex justify-content-between align-items-center">
            <h5 class="card-title mb-0">Sentiment Trends Over Time</h5>
            <div class="d-flex align-items-center">
              <!-- Month filter dropdown -->
              <div class="dropdown me-3">
                <button class="btn btn-outline-secondary dropdown-toggle" type="button" id="monthDropdown" data-bs-toggle="dropdown" aria-expanded="false">
                  <span id="selectedMonthLabel">Loading...</span>
                </button>
                <ul class="dropdown-menu" aria-labelledby="monthDropdown" id="monthDropdownMenu">
                  <li><a class="dropdown-item" href="#" data-month="all">All Months</a></li>
                  <% for(let i = 1; i <= 12; i++) { %>
                    <li>
                      <a class="dropdown-item" href="#" data-month="<%= i.toString().padStart(2, '0') %>">
                        <%= new Date(0, i-1).toLocaleString('default', { month: 'long' }) %>
                      </a>
                    </li>
                  <% } %>
                </ul>
              </div>
              
              <!-- Year filter dropdown -->
              <div class="dropdown">
                <button class="btn btn-outline-secondary dropdown-toggle" type="button" id="yearDropdown" data-bs-toggle="dropdown" aria-expanded="false">
                  <span id="selectedYearLabel">Loading...</span>
                </button>
                <ul class="dropdown-menu" aria-labelledby="yearDropdown" id="yearDropdownMenu">
                  <li><a class="dropdown-item" href="#" data-year="all">All Years</a></li>
                  <% availableYears.forEach(year => { %>
                    <li>
                      <a class="dropdown-item" href="#" data-year="<%= year %>">
                        <%= year %>
                      </a>
                    </li>
                  <% }); %>
                </ul>
              </div>
            </div>
          </div>
          <div class="card-body">
            <div class="chart-container" style="position: relative; width: 100%; height: 350px;">
              <canvas id="timeSeriesChart"></canvas>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<%- include('./partials/footer') %>

<!-- Scripts -->
<script src="/js/chart.umd.js"></script>
<script>
  // Get data from server
  const stats = <%- JSON.stringify(stats) %>;
  const monthlyDetailData = <%- JSON.stringify(monthlyDetailData) %>;
  const availableYears = <%- JSON.stringify(availableYears) %>;
  const latestYear = "<%= latestYear %>";
  
  // Define WCAG-compliant color mapping
  const colors = {
    'positif': 'rgba(46, 125, 50, 0.8)',    // Dark green - high contrast, WCAG AA compliant
    'negatif': 'rgba(183, 28, 28, 0.8)',    // Dark red - high contrast, WCAG AA compliant
    'netral': 'rgba(66, 66, 66, 0.8)',      // Dark gray - high contrast, WCAG AA compliant
    'puas': 'rgba(13, 71, 161, 0.8)',       // Dark blue - high contrast, WCAG AA compliant
    'kecewa': 'rgba(230, 81, 0, 0.8)'       // Dark orange - high contrast, WCAG AA compliant
  };
  
  // Get current date
  const currentDate = new Date();
  const currentYear = currentDate.getFullYear().toString();
  const currentMonth = (currentDate.getMonth() + 1).toString().padStart(2, '0');
  
  // Set initial values to current month and year, fallback to latest data if current not available
  let selectedYear = availableYears.includes(currentYear) ? currentYear : latestYear;
  let selectedMonth = currentMonth;
  
  // Check if data exists for current month, otherwise default to 'all'
  let currentMonthHasData = monthlyDetailData.some(item => {
    const [itemYear, itemMonth] = item.year_month.split('-');
    return itemYear === selectedYear && itemMonth === selectedMonth;
  });
  
  if (!currentMonthHasData) {
    selectedMonth = 'all';
  }
  
  let timeSeriesChart;
  
  // Create charts and update cards
  document.addEventListener('DOMContentLoaded', function() {
    const labels = stats.labels;
    const data = labels.map(label => stats.counts[label]);
    
    // Apply colors to progress bars
    applyProgressBarColors();
    
    // Update sentiment cards
    updateSentimentCards(labels, data);
    
    // Create sentiment chart
    createSentimentChart(labels, data);
    
    // Setup year dropdown with current year selected
    setupYearDropdown();
    
    // Setup month dropdown with current month selected
    setupMonthDropdown();
    
    // Create time series chart with default filters
    createTimeSeriesChart(stats.labels, selectedMonth, selectedYear);
  });
  
  // Apply colors to progress bars
  function applyProgressBarColors() {
    const sentimentCards = ['positif', 'negatif', 'netral', 'puas', 'kecewa'];
    sentimentCards.forEach(sentiment => {
      const progressBar = document.getElementById(`${sentiment}Progress`);
      if (progressBar) {
        progressBar.style.backgroundColor = colors[sentiment];
      }
    });
  }
  
  // Update sentiment cards with data
  function updateSentimentCards(labels, data) {
    const totalReviews = data.reduce((sum, current) => sum + current, 0);
    
    // Update total reviews card
    document.getElementById('totalReviews').textContent = totalReviews;
    
    // Update each sentiment card
    labels.forEach((label, index) => {
      const count = data[index];
      const percentage = totalReviews > 0 ? Math.round((count / totalReviews) * 100) : 0;
      
      // Update count
      document.getElementById(`${label}Count`).textContent = count;
      
      // Update progress bar
      const progressBar = document.getElementById(`${label}Progress`);
      progressBar.style.width = `${percentage}%`;
      progressBar.setAttribute('aria-valuenow', percentage);
    });
  }
  
  // Create sentiment distribution chart
  function createSentimentChart(labels, data) {
    const backgroundColors = labels.map(label => colors[label]);
    const ctx = document.getElementById('sentimentChart').getContext('2d');
    
    new Chart(ctx, {
      type: 'bar',
      data: {
        labels: labels,
        datasets: [{
          label: 'Number of Reviews',
          data: data,
          backgroundColor: backgroundColors,
          borderColor: backgroundColors.map(color => color.replace('0.8', '1')),
          borderWidth: 1
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false, 
        plugins: {
          legend: { display: false },
          tooltip: {
            callbacks: {
              label: function(context) {
                return `Reviews: ${context.raw}`;
              }
            }
          }
        },
        scales: {
          y: {
            beginAtZero: true,
            ticks: { precision: 0 }
          }
        }
      }
    });
  }
  
  // Setup year dropdown
  function setupYearDropdown() {
    const yearDropdownItems = document.querySelectorAll('#yearDropdownMenu .dropdown-item');
    const selectedYearLabel = document.getElementById('selectedYearLabel');
    
    // Set the initial year in the UI
    selectedYearLabel.textContent = selectedYear;
    
    // Mark the current year as active in the dropdown
    yearDropdownItems.forEach(item => {
      if (item.dataset.year === selectedYear) {
        item.classList.add('active');
      } else {
        item.classList.remove('active');
      }
      
      item.addEventListener('click', function(e) {
        e.preventDefault();
        
        // Remove active class from all items
        yearDropdownItems.forEach(i => i.classList.remove('active'));
        
        // Add active class to clicked item
        this.classList.add('active');
        
        // Update selected year and label
        selectedYear = this.dataset.year;
        selectedYearLabel.textContent = selectedYear === 'all' ? 'All Years' : selectedYear;
        
        // If "All Years" is selected, automatically set month to "All Months"
        if (selectedYear === 'all') {
          selectedMonth = 'all';
          
          // Update the month dropdown UI
          const monthDropdownItems = document.querySelectorAll('#monthDropdownMenu .dropdown-item');
          monthDropdownItems.forEach(i => i.classList.remove('active'));
          document.querySelector('#monthDropdownMenu [data-month="all"]').classList.add('active');
          document.getElementById('selectedMonthLabel').textContent = 'All Months';
          
          // Disable month dropdown when viewing all years
          document.getElementById('monthDropdown').classList.add('disabled');
          document.getElementById('monthDropdown').setAttribute('disabled', 'disabled');
        } else {
          // Re-enable month dropdown
          document.getElementById('monthDropdown').classList.remove('disabled');
          document.getElementById('monthDropdown').removeAttribute('disabled');
        }
        
        // Refresh chart
        createTimeSeriesChart(stats.labels, selectedMonth, selectedYear);
      });
    });
  }
  
  // Setup month dropdown
  function setupMonthDropdown() {
    const monthDropdownItems = document.querySelectorAll('#monthDropdownMenu .dropdown-item');
    const selectedMonthLabel = document.getElementById('selectedMonthLabel');
    
    // Set the initial month in the UI
    if (selectedMonth === 'all') {
      selectedMonthLabel.textContent = 'All Months';
    } else {
      const monthIndex = parseInt(selectedMonth) - 1;
      selectedMonthLabel.textContent = new Date(0, monthIndex).toLocaleString('default', { month: 'long' });
    }
    
    // Mark the current month as active in the dropdown
    monthDropdownItems.forEach(item => {
      if (item.dataset.month === selectedMonth) {
        item.classList.add('active');
      } else {
        item.classList.remove('active');
      }
      
      item.addEventListener('click', function(e) {
        e.preventDefault();
        
        // If all years is selected, don't allow month selection
        if (selectedYear === 'all') {
          return;
        }
        
        // Remove active class from all items
        monthDropdownItems.forEach(i => i.classList.remove('active'));
        
        // Add active class to clicked item
        this.classList.add('active');
        
        // Update selected month and label
        selectedMonth = this.dataset.month;
        
        if (selectedMonth === 'all') {
          selectedMonthLabel.textContent = 'All Months';
        } else {
          const monthIndex = parseInt(selectedMonth) - 1;
          const monthName = new Date(0, monthIndex).toLocaleString('default', { month: 'long' });
          selectedMonthLabel.textContent = monthName;
        }
        
        // Refresh chart
        createTimeSeriesChart(stats.labels, selectedMonth, selectedYear);
      });
    });
  }
  
  // Create time series chart
  function createTimeSeriesChart(labels, month = 'all', year = null) {
    if (year) selectedYear = year;
    if (month) selectedMonth = month;
    
    let chartLabels;
    const chartData = {};
    
    // Handle "All Years" selection
    if (selectedYear === 'all') {
      // Get data by year
      const yearlyData = {};
      
      // Group all data by year and sentiment
      monthlyDetailData.forEach(item => {
        const itemYear = item.year_month.split('-')[0];
        
        if (!yearlyData[itemYear]) {
          yearlyData[itemYear] = {};
        }
        
        if (!yearlyData[itemYear][item.sentiment]) {
          yearlyData[itemYear][item.sentiment] = 0;
        }
        
        yearlyData[itemYear][item.sentiment] += parseInt(item.count);
      });
      
      // Sort years
      const years = Object.keys(yearlyData).sort();
      chartLabels = years;
      
      // Initialize data structure
      labels.forEach(sentiment => {
        chartData[sentiment] = years.map(year => 
          yearlyData[year] && yearlyData[year][sentiment] ? yearlyData[year][sentiment] : 0
        );
      });
    } else {
      // Filter data based on selected year
      let filteredData = monthlyDetailData.filter(item => {
        const itemYear = item.year_month.split('-')[0];
        return itemYear === selectedYear;
      });
      
      if (selectedMonth === 'all') {
        // Show data for all months in selected year
        chartLabels = Array.from({length: 12}, (_, i) => {
          const monthIndex = i;
          return new Date(parseInt(selectedYear), monthIndex).toLocaleString('default', { month: 'short' });
        });
        
        // Initialize data structure
        labels.forEach(sentiment => {
          chartData[sentiment] = Array(12).fill(0);
        });
        
        // Group data by month and sentiment
        const monthlySums = {};
        
        filteredData.forEach(item => {
          const itemMonth = item.year_month.split('-')[1];
          const monthIndex = parseInt(itemMonth) - 1; // Convert to 0-based index
          
          if (!monthlySums[monthIndex]) {
            monthlySums[monthIndex] = {};
          }
          
          if (!monthlySums[monthIndex][item.sentiment]) {
            monthlySums[monthIndex][item.sentiment] = 0;
          }
          
          monthlySums[monthIndex][item.sentiment] += parseInt(item.count);
        });
        
        // Fill in the data for the chart
        for (const monthIndex in monthlySums) {
          for (const sentiment in monthlySums[monthIndex]) {
            if (labels.includes(sentiment)) {
              chartData[sentiment][monthIndex] = monthlySums[monthIndex][sentiment];
            }
          }
        }
      } else {
        // Show data for selected month
        const monthIndex = parseInt(selectedMonth) - 1;
        chartLabels = [new Date(parseInt(selectedYear), monthIndex).toLocaleString('default', { month: 'long' })];
        
        // Group data by sentiment for the selected month
        const sentimentSums = {};
        
        filteredData.forEach(item => {
          const itemMonth = item.year_month.split('-')[1];
          
          if (itemMonth === selectedMonth) {
            if (!sentimentSums[item.sentiment]) {
              sentimentSums[item.sentiment] = 0;
            }
            
            sentimentSums[item.sentiment] += parseInt(item.count);
          }
        });
        
        // Set up chart data
        labels.forEach(sentiment => {
          chartData[sentiment] = [sentimentSums[sentiment] || 0];
        });
      }
    }
    
    const datasets = labels.map(sentiment => {
      return {
        label: sentiment.charAt(0).toUpperCase() + sentiment.slice(1),
        data: chartData[sentiment],
        borderColor: colors[sentiment].replace('0.8', '1'),
        backgroundColor: colors[sentiment].replace('0.8', '0.2'),
        borderWidth: 2,
        tension: 0.3,
        fill: true,
      };
    });
    
    const timeSeriesCtx = document.getElementById('timeSeriesChart').getContext('2d');
    
    // Destroy existing chart if it exists
    if (timeSeriesChart) {
      timeSeriesChart.destroy();
    }
    
    // Determine chart type based on context
    let chartType;
    if (selectedYear === 'all' || (selectedMonth === 'all' && selectedYear !== 'all')) {
      chartType = 'line';
    } else {
      chartType = 'bar';
    }
    
    timeSeriesChart = new Chart(timeSeriesCtx, {
      type: chartType,
      data: {
        labels: chartLabels,
        datasets: datasets
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        interaction: {
          mode: 'index',
          intersect: false,
        },
        plugins: {
          legend: { 
            position: 'top',
            labels: {
              usePointStyle: true,
              pointStyle: 'circle'
            }
          },
          tooltip: {
            mode: 'index',
            intersect: false
          }
        },
        scales: {
          y: {
            beginAtZero: true,
            stacked: false,
            ticks: { precision: 0 }
          },
          x: {
            ticks: {
              maxRotation: 45,
              minRotation: 45
            }
          }
        }
      }
    });
  }
</script>